\subsection{Uncertainty Model} \slabel{uncertainty-model}
Let $(\O, \F, \P)$ be a complete probability space where $\O$ is a set of outcomes, $\F$ is a $\sigma$-algebra of events on $\O$, and $\P: \O \to [0, 1]$ is a probability measure. The system depends on a number of uncertain parameters denoted by a set of random variables (\rvs) $\vU(\o) = \{ \U_i(\o): i = 1, \dots, \Nup \}$, $\o \in \O$. Since the knowledge of the \emph{joint} distribution functions of $\vU(\o)$ is unrealistic in practice,\footnote{If the joint distribution function of $\vU(\o)$ is available, Rosenblatt's transformation is the most preferable choice.} only the \emph{marginal} distribution functions $\CDF_{\U_i}(\u)$ and a matrix of correlations $\mCorr_\vU$ are assumed to be known. $\mCorr_\vU$ captures either solely linear correlations, which is denoted by $\mLCorr_\vU$, via the Pearson's correlation coefficient (i.e., the matrix is the ordinary correlation matrix) or nonlinear correlations as well, which is denoted by $\mNCorr_\vU$, via a rank correlation coefficient (e.g., the Spearman's rho or Kendall's tau).

\subsection{Platform and Application Models} \slabel{platform-model} \slabel{application-model}
The system consists of two major components: a multiprocessor platform $\platform$ and an application $\application$. $\platform$ is composed of a set of processing elements $\{ \processor_i: i = 1, \dots, \Npe \}$ equipped with thermal package. All the components of $\platform$ are characterized by a thermal specification $\specification$ of the system defined as a collection of temperature-related information. The application $\application$ is given as a directed acyclic graph $(\tasks, \dependencies)$ where $\tasks = \{ \task_i: i = 1, \dots, \Nts \}$ is a set of tasks, and $\dependencies = \{ (\task_{i_1}, \task_{i_2}) \}$ is a set of data dependencies between $\tasks$. The binary matrix $\mM = (m_{ij}) \in \{ 0, 1 \}^{\Npe \times \Nts}$ defines the mapping of $\application$ onto $\platform$ where $m_{ij}$ is equal to one only if the $j$th task is to be executed on the $i$th processing element; otherwise, the element $m_{ij}$ is zero.

Each task $\task_i \in \tasks$ is characterized by its execution time (duration) $\D_i(\o) \in \real_+$ defined as a \rv. $\D_i(\o)$, $\forall i$, are assumed to be given as functionals of $\vU(\o)$, i.e., $\D_i(\o) = f(\vU(\o))$. In the simplest case, $\D_i(\o) \equiv \U_i(\o)$. Taking a certain amount of time $\d_i = \D_i(\o)$ for some $\o \in \O$, a task is assumed to reside in a certain power consumption mode. Therefore, the modes, denoted by $\PT_i(\o) \in \real_+$, $\forall i$, are assumed to be given as functions of the execution time of the tasks, i.e., $\PT_i(\o) = f(\D_i(\o))$. As such detailed dependencies are hard to capture, $\PT_i(\o)$ can reasonably be approximated by constants $\PT_i$.
