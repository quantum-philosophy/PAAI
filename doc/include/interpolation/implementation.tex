The life cycle of interpolation has roughly two phases: construction and usage.
The construction phase involves sampling the target function $\f$ at collocation
points and produces a set of artifacts needed for the actual interpolation at
the usage phase. Regarding the aforementioned artifacts, it can be seen in
\eref{tensor-surplus-1d} that an approximant is entirely characterized by a set
of indexing pairs $\{ (\vi, \vj) \}$ and the corresponding surpluses $\{
\surplus(\vx^\vi_\vj) \}$. Recall that the multi-index $\vi$ captures the levels
of interpolation with respect to each dimension, and $\vj$ captures the
corresponding orders (see \sref{tensor-product}). Each pair $(\vi, \vj)$
unambiguously maps to a collocation point and a basis function, which, together
with the corresponding surplus, allow one to evaluate the interpolant at any
point of interest.

\input{include/algorithms/construct}
The conceptual code corresponding to the construction phase is given in
\aref{construct} called \token{Construct}.

\begin{remark}
In the pseudocodes presented in this paper, many implementation details---such
as memory management---have been purposely omitted in order to distill the core
ideas. In addition, some of the auxiliary subroutines that the algorithms make
use of are not described as being self-explanatory.
\end{remark}

The input to \token{Construct}, \token{target}, is the function to be
approximated. The output, \token{surrogate}, is a structure containing the
artifacts mentioned earlier: indices and surpluses. The outermost loop on line~4
corresponds to the increasing level of Smolyak's interpolation, which is denoted
by $l$ in \eref{smolyak} and \eref{smolyak-incremental} and by \token{level} in
the code. The \token{indices} variable is a working set containing the indexing
pairs specific to the current level. The set is initially populated on line~2 by
the indices of the zeroth level. For the open Newton--Cotes rule, it is the zero
pair $(\v{0}, \v{0})$, which correspond to the root node $(0.5)_{i = 1}^\nin$
and the basis function $\e^\v{0}_\v{0}(\vx) = 1$. \token{ComputeNodes} on line~5
takes a set of indexing pairs and returns the corresponding nodes of the sparse
grid; see \sref{collocation-nodes}. \token{Execute} on line~6 calls the target
function at each of the given nodes and returns the corresponding values.
\token{Evaluate} on line~7 uses the surrogate constructed so far in order to
calculate an approximation to the values of \token{target} obtained on line~6;
\token{Evaluate} is \aref{evaluate}, and it will be described separately.
\token{Append} on line~9 ameliorates the surrogate by extending it with the
indices and surpluses of the current iteration/level. The check on line~10 is to
stop the algorithm when it reaches a limit on a resources such as the
construction time, interpolation level, and total number of \token{target}'s
invocations. The loop on line~14 iterates over the collocation nodes of the
current level and identifies those nodes that need refinement.

\input{include/algorithms/evaluate}
The pseudocode of the interpolating procedure is given in \aref{evaluate}.
