\begin{reviewer}
The article proposes a system-level framework for early estimation and analysis
of an electronic system given a task graph and a heterogeneous platform. The
framework proposes a general approach which is based on hybrid adaptivity on a
sparse grid  for early estimation for the different quality of interest (e.e
power, delay).

Here are my comments to the author:

\clabel{1}{1}
The most problem of this article is the style of presentation. it seems that the
article tries to make the problem and approach more complicated than what it is.
The style of writing in particular approach and implementation is very confusing
and completed. It makes the paper very difficult to follow. I do like the
motivation example in the introduction, however, the rest of paper significantly
lack the real examples and illustrative figures. My suggestion is to build a
story with a real example of a task graph and a platform when describing the
approach and implementation.
\end{reviewer}

\begin{authors}
Please refer to \cref{0}{1} for our response.

Regarding the last sentence of this comment, the example mentioned in
\cref{0}{1} is synthetic; however, its synthetic nature allows us to make the
corresponding story with a platform and a task graph simple to follow and yet
sufficiently complex to ensure that the example diligently serves its intended
purpose, which is to give the reader the big picture of the proposed framework.
It is a road map that the reader can always refer to whenever the reader needs a
clarification or confirmation about how certain parts of the framework. We
suppose that it is the primary concern of the reviewer here, and we hope that
giving the illustrative example more attention in the revised version of the
paper addresses the concern sufficiently well.

\begin{actions}
  \action{Please refer to \cref{0}{1} for our actions.}
\end{actions}
\end{authors}

\begin{reviewer}
\clabel{1}{2}
The second major problem of the article is the experimental results. It claimed
in the article, the approach can be applied to different platforms with
different heterogeneous processors, the experimental results stay as a random
statistical model of platform and task graphs with no insight correlated to the
challenges of a real platform. I expect authors can apply their approach their
to measure a metric when an abstract but real application mapped to an abstract
model of a real platform.
\end{reviewer}

\begin{authors}
Please refer to \cref{0}{2} for our response.

\begin{actions}
  \action{Please refer to \cref{0}{2} for our actions.}
\end{actions}
\end{authors}

\begin{reviewer}
\clabel{1}{3}
Wording suggestion, please replace the ``quality of interest'' with ``metric''.
It is more understandable and less confusing.
\end{reviewer}

\begin{authors}
The reason we chose the term \emph{quantity of interest} (and its shortcut
\emph{quantity}) is that it is the one frequently used in the general literature
on uncertainty quantification. However, we agree with the reviewer that, in this
particular context, it might not be that common and, therefore, might lead to an
unnecessary increase in cognitive load. The usage of \emph{metric} in place of
\emph{quantity} is more appropriate and less confusing. In the revised version,
we still occasionally use the \emph{of interest} ending in order to add weight
to the term and make it stand out when it is needed.

\begin{actions}
  \action{The term \emph{quantity of interest} and its occasional shortcut
  \emph{quantity} have been replaced throughout the paper by the term
  \emph{metric of interest} or simply by \emph{metric}.}
\end{actions}
\end{authors}

\begin{reviewer}
\clabel{1}{4}
It is mentioned in the article that the implementation is  based on [4],
[5],[6]. I like to see the difference between the proposed implementation and
the ones presented in [4][5][6]. There is no comparison in the related work.
They all are based on hybrid adaptivity on a sparse grid.
\end{reviewer}

\begin{authors}
The reviewer uses the word \emph{implementation}. However, we suspect that the
comment might be more concerned with the mathematics behind the interpolation
algorithm rather than with the implementation of this algorithm. In order to be
the safe side, we shall cover both perspectives.

The proposed framework relies on the mathematics developed in [Klimke,~2006],
[Ma,~2009], and [Jakeman,~2012]. However, it should be well understood that we
do not develop this mathematics in the paper under submission; we put it into
practice. The aforementioned bodies of research are theoretical. They do provide
numerical results; however, their focal point is on the interpolation machinery
itself. They cover different aspects of what we present in Sec.~IX,
``Interpolation,'' except for Sec.~IX-F, ``Implementation.'' For instance,
interpolation with global adaptivity (dimension-wise) is presented in
[Klimke,~2006]; the work in [Ma,~2009] is concerned with local adaptivity; and,
in [Jakeman,~2012], the authors show how to combine global and local adaptivity
strategies, which is what we refer to as hybrid adaptivity in the paper. In
addition, each work puts emphasis on different choices of collocation nodes,
basis functions, and refinement criteria. We have explored various
configurations and presented in Sec.~IX the one that we consider to be the most
adequate for our problem. All in all, the mathematics in Sec.IX-A--IX-E is our
distilled version of what is given in [Klimke,~2006], [Ma,~2009], and
[Jakeman,~2012]; there are no conceptual differences.

Let us now turn to the implementation. In [Klimke,~2006], the authors discuss
their algorithms in a great level of detail and even provide a MATLAB package
for interpolation on sparse
grids.\footnote{\texttt{http://www.ians.uni-stuttgart.de/spinterp/}} However,
their code is concerned with a drastically different (and the simplest)
adaptivity strategy than the one we use. Therefore, their implementation is not
directly comparable with ours. The same applies to the work in [Ma,~2009]. In
this case, although the authors had not published their implementation, they
were kind enough to share it with us when we contacted them directly. Their code
was valuable for us as an intermediate step toward our final algorithm; we
acknowledge their help in the paper. The basic idea behind the adaptivity
strategy described in Sec.~IX-E is given in [Jakeman,~2012]. The authors did not
publish any code and did not rely to us when we wrote to them. Therefore, it is
not possible for us to tell how their implementation compares with ours.
In addition, we are not aware of any other implementation of the interpolation
algorithm described in Sec.~IX. Furthermore, to the best of our knowledge, we
are the first ones to apply the algorithm in the context of uncertainty
quantification of electronic systems.

We would like to emphasize that the interpolation algorithm in Sec.~IX is a tool
which we use to solve the problem at hand. This tool and the proposed framework
itself, which the tool is a part of, conceptually belong to different levels;
they serve different purposes. Based on this reasoning, we do not discuss
[Klimke,~2006], [Ma,~2009], and [Jakeman,~2012] in the section on prior work,
Sec.~II. Instead, in that section, we elaborate on the prior studies that are
related to uncertainty quantification of electronic systems, which is the topic
of the present paper.

\begin{actions}
  \action{It has been emphasized in Sec.~III and Sec.~IX that the mathematics in
  Sec.~IX-A--IX-E is a distilled version of the one developed in [Klimke,~2006],
  [Ma,~2009], and [Jakeman,~2012].}

  \action{The adaptivity strategies that [Klimke,~2006], [Ma,~2009], and
  [Jakeman,~2012] are concerned with have been clarified in Sec.IX-E.}
\end{actions}
\end{authors}

\begin{reviewer}
\clabel{1}{5}
Authors see the heterogeneous platform as a heterogeneous processor elements
with behavior modeled as Gaussian distribution. Real platforms are the
combination of processors as well as communication fabric and shared memory with
run-time and data-dependent arbitration. It is not clear how the approach can
capture the effect of communication and shared memory when estimating a certain
metric.
\end{reviewer}

\begin{authors}
Let us clarify the situation with the Gaussian distributions mentioned in
Sec.~VIII-A, ``Uncertain Parameters.'' First of all, it is important to note
that the proposed framework does not make any assumptions about the joint
probability distribution of the uncertain parameters. The description given in
the second half of Sec.~VIII-A is an example of how the parameters can be
modeled. The reason we put much emphasis on this example is that we consider it
to be the most common scenario in practice as, in practice, the knowledge of the
distribution of the parameters is typically limited; see Remark~1. It is also
important to note that, even in this practical scenario, the parameters are not
modeled as Gaussian. The parameters have arbitrary marginal distributions. For
instance, we use beta distributions in the motivational example in Sec.~I
(uniform is a special case of beta), in the illustrative example in Sec.~VII,
and in the experimental results in Sec.~XI. What is assumed to be Gaussian in
the scenario in Sec.~VIII-A is the copula of the parameters, which together with
the marginals define the joint distribution of the parameters. The reason for
highlighting this special case is, again, practical. As it is explained in
Remark~1, given a correlation matrix, the correlation structure of the
parameters is often expressed as a Gaussian copula using such techniques as the
Nataf transformation described in [Liu,~1986].

Let us now move on to the last two sentences of the comment. In our problem
formulation stated in Sec.~V, the distribution of the uncertain parameters is
assumed to be given. For instance, it can be specified as a set of marginal
distributions and a correlation matrix as we discuss in Sec.~VIII-A. The way
this information is obtained is outside of the scope of this paper. It is also
assumed that there is a simulator of the system at hand that takes in a concrete
assignment of the uncertain parameters and outputs the corresponding value of
the metric of interest. The crucial point here is that the proposed framework is
completely indifferent to what the simulator does under the hood, which is why
the simulator is referred to as a ``black box'' in the paper. Consequently,
provided that the simulator is capable of modeling the effect of communications
and shared resources when calculating the metric, the framework will take this
effect into account automatically. In fact, this is exactly what happens in the
real-life example that has been added to the paper. In this case, the simulator,
Sniper, simulates a multi-threaded application running a platform which has
three CPUs sharing an L3 cache; see \cref{0}{2}.

\begin{actions}
  \action{It has been emphasized in Sec.~V and Sec.~VIII-A that that framework
  does not assume any particular probability distribution of the uncertain
  parameters.}

  \action{It has been mentioned in Sec.~VIII that the modeling capabilities of
  the framework are naturally inherited from the capabilities of the chosen
  simulator.}
\end{actions}
\end{authors}
