The life cycle of interpolation has roughly two stages: construction and usage.
The construction stage invokes $\f$ at a set of collocation nodes and produces
certain artifacts. The usage stage estimates the values of $\f$ at a set of
arbitrary (likely unseen) points solely by manipulating the artifacts. It can be
seen in \eref{approximation} that an interpolant is entirely characterized by a
set of triplets $\{ (\vi_k, \vj_k, \surplus(\vx_{\vi_k \vj_k}) \}_k$, which is
obtained by following the recursion and ``flattening'' the nested sums in
\eref{approximation}. These triples are the above-mentioned artifacts.

\input{include/assets/algorithms/construct}
The conceptual code corresponding to the construction stage is given in
\aref{construct} called \token{Construct}.

\begin{remark}
The purpose of the pseudocodes presented here is to give the big picture of the
interpolation algorithm, not minute implementation details. Since we open-source
our code, all the details can be found and studied at online \cite{sources}.
\end{remark}

The input \token{target} is a function $\f$ to be approximated. The output
\token{surrogate} is a structure containing the artifacts mentioned earlier:
indexing pairs and surpluses; hereafter, the former are referred to as just
indices. The key steps of the \token{Construct} algorithm are as follows.

\begin{compactlist}

\point{Line~4:} Each iteration of the outermost loop corresponds to a level of
Smolyak's interpolation, which is denoted by $l$ in \eref{smolyak-hierarchical}
and by \token{level} in the code. The \token{indices} variable is a working set
containing the indices of the current (in progress) level. The set is initially
populated on line~2 by the indices of level~0, which is just $\{ (\v{0}, \v{0})
\}$ for the Newton--Cotes grid.

\point{Line~5:} \token{grid.ComputeNodes} takes a set of indices and returns the
corresponding (multidimensional) nodes of the underlying sparse grid; see
\sref{collocation-nodes}.

\point{Line~6:} \token{Invoke} exercises the target function at each of the
given nodes and returns the corresponding values. This is a prominent candidate
for parallelization since each collocation node can be evaluated independently
from the rest.

\point{Line~7:} \token{Evaluate} utilizes the interpolant constructed so far in
order to calculate approximations to the true values of the target function
obtained on line~6. The \token{Evaluate} function is \aref{evaluate}, and it
will be discussed separately.

\point{Line~9--10:} \token{Append} ameliorates the surrogate by extending it
with the indices and surpluses of the current iteration.

\point{Line~11:} The check is to stop the algorithm when it reaches a
user-defined limit such as the maximum level of interpolation, number of
\token{target}'s invocations, or time spent on interpolation.

\point{Line~14:} The loop iterates over the surpluses of the current level and
identifies those indices that need refinement. The \token{IsAccurate} function
represents a refinement strategy and might not necessarily be solely based on
the surpluses. In our experiments, we use the formula given in \eref{score}.

\point{Line~18:} The check is to stop the algorithm when there is nothing left
to refine, which is dictated by \token{IsAccurate}.

\point{Line~21:} \token{grid.ComputeNeighbors} takes the indices selected for
refinement and returns the corresponding child indices of the next level; see
\fref{rule} and \sref{adaptivity}.

\end{compactlist}

\input{include/assets/algorithms/evaluate}
Let us now turn to the usage stage of interpolant. The corresponding pseudocode
is given in \aref{evaluate}, which is called \token{Evaluate}. This algorithm is
also involved in the construction stage; see \aref{construct}, line~7. The main
steps of the \token{Evaluate} algorithm are given below.

\begin{compactlist}

\point{Line~6:} The inner loop directly corresponds to
\eref{smolyak-hierarchical} with the exception that, due to adaptivity, the loop
generally iterates over a subset of the summands in the aforementioned equation,
which we discussed in \sref{adaptivity}.

\point{Line~6:} \token{basis.Compute} takes a pair $(\vi, \vj)$ and a point and
returns the value of the (multidimensional) basis function corresponding to the
pair evaluated at the point; see \sref{basis-functions}.

\end{compactlist}

To recapitulate, in this section, we have presented the key component of the
proposed framework for probabilistic analysis of electronic systems: an
efficient approach to multidimensional interpolation. The interpolation
technique is based on the Smolyak algorithm, which enables the interpolation to
be performed in an adaptive hierarchical manner, highly beneficial for practical
computations. The overall technique has been consolidated in \aref{construct}
and \aref{evaluate}.
