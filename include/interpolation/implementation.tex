The life cycle of interpolation has roughly two stages: construction and usage.
The construction stage invokes $\f$ at a set of collocation nodes and produces
certain artifacts. The usage stage estimates the values of $\f$ at a set of
arbitrary points by manipulating the artifacts. In this subsection, we shall
have a look at the pseudocodes of the two stages. The purpose here is to give
the big picture; a lot of implementation details are purposely omitted. All the
details, however, can be found and studied at online as our implementation is
open-source \cite{sources}.

Let us first make a general note. We found it beneficial to the clarity and ease
of implementation to collapse the two sums in \eref{approximation} into one.
This requires storing a level index $\vi = (i_k)_{k = 1}^\nin$ and an order
index $\vj = (j_k)_{k = 1}^\nin$ for each interpolation element. Furthermore, it
is advantageous to encode each pair $(i_k, j_k)$ as a single unsigned integer,
which, in particular, eliminates excessive memory usage. In multiple dimensions,
this results in a single vector $\vl = (\iota_k)_{k = 1}^\nin$, which we simply
call an index. The encoding that we utilize is as follows:
\[
  \iota_k = i_k \lor (j_k \ll \n_\text{bits})
\]
where $\lor$ and $\ll$ are the bitwise \up{OR} and logical left shift,
respectively, and $\n_\text{bits}$ is the number of bits reserved for storing
Smolyak levels, which can be adjusted according to the maximum permitted
deepness of interpolation.

\input{include/assets/algorithms/construct}
The pseudocode of the construction stage is given in \aref{construct} called
\token{Construct}. The \token{target} input is a function $\f$ to be
approximated. The \token{surrogate} output is a set of tuples $\{ (\vl_k,
\surplus(\vx_{\vl_k}) \}_k$, which is a comprehensive characterization of an
interpolant. The routine works as follows.

\begin{compactlist}

\point{Line~2:} Each iteration is an interpolation step in \eref{approximation};
it has a state represented by a structure with multiple fields \token{s}. The
\token{First} function returns the initial state of the first step so that the
\token{indices} field of \token{s} is initialized with the indices of that step.
Then the body of the loop populates the rest of the fields of \token{s} so that
\token{Next} can adequately produce the initial state for the next step. The
process terminates when a stopping condition is satisfied, which is controlled
by \token{Check}. \token{Next} and \token{Check} operate according to the logic
discussed in \sref{adaptivity}.

\point{Line~3:} \token{Locate} converts the step's indices into coordinates
(that is, $\vl_k$ into $\vx_{\vl_k}$) in accordance with the utilized grid.

\point{Line~4:} \token{Invoke} exercises \token{target} at the collocation
nodes. This function a prominent candidate for parallelization since each node
can be evaluated independently from the rest.

\point{Line~5:} \token{Evaluate} exercises the interpolant constructed so far at
the collocation nodes, approximating the values obtained on line~4. This
function will be discussed separately.

\point{Line~6:} \token{Subtract} computes the difference between the true and
approximated values of \token{target}, which yields the step's hierarchical
surpluses $\surplus(\vx_\vl)$, similar to \eref{surplus}.

\point{Line~7:} \token{Assess} calculates the scores of the new collocation
nodes based primarily on their surpluses; see \eref{score}.

\point{Line~8:} \token{Append} ameliorates the surrogate by extending it with
the indices and surpluses of the current iteration.

\end{compactlist}

\input{include/assets/algorithms/evaluate}
Let us now turn to the usage stage of interpolant. The corresponding pseudocode
is given in \aref{evaluate}, which is called \token{Evaluate}. This algorithm is
also involved in the construction stage; see \aref{construct}, line~7. The main
steps of the \token{Evaluate} algorithm are given below.

\begin{compactlist}

\point{Line~6:} The inner loop directly corresponds to
\eref{smolyak-hierarchical} with the exception that, due to adaptivity, the loop
generally iterates over a subset of the summands in the aforementioned equation,
which we discussed in \sref{adaptivity}.

\point{Line~6:} \token{basis.Compute} takes a pair $(\vi, \vj)$ and a point and
returns the value of the (multidimensional) basis function corresponding to the
pair evaluated at the point; see \sref{basis-functions}.

\end{compactlist}

To recapitulate, in this section, we have presented the key component of the
proposed framework for probabilistic analysis of electronic systems: an
efficient approach to multidimensional interpolation. The interpolation
technique is based on the Smolyak algorithm, which enables the interpolation to
be performed in an adaptive hierarchical manner, highly beneficial for practical
computations. The overall technique has been consolidated in \aref{construct}
and \aref{evaluate}.
