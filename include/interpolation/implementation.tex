The life cycle of interpolation has roughly two stages: construction and usage.
The construction stage invokes $\f$ at a set of collocation nodes and produces
certain artifacts. The usage stage estimates the values of $\f$ at a set of
arbitrary points by manipulating the artifacts. In this subsection, we shall
have a look at the pseudocodes of the two stages. The purpose here is to give
the big picture; a lot of implementation details are purposely omitted. All the
details, however, can be found and studied at online as our implementation is
open-source \cite{sources}.

Let us first make a general note. We found it beneficial to the clarity and ease
of implementation to collapse the two sums in \eref{approximation} into one.
This requires storing a level index $\vi = (i_k)_{k = 1}^\nin$ and an order
index $\vj = (j_k)_{k = 1}^\nin$ for each interpolation element. Furthermore, it
is advantageous to encode each pair $(i_k, j_k)$ as a single unsigned integer,
which, in particular, eliminates excessive memory usage. In multiple dimensions,
this results in a single vector $\vl = (\iota_k)_{k = 1}^\nin$, which we simply
call an index. The encoding that we utilize is as follows:
\[
  \iota_k = i_k \lor (j_k \ll \n_\text{bits})
\]
where $\lor$ and $\ll$ are the bitwise \up{OR} and logical left shift,
respectively, and $\n_\text{bits}$ is the number of bits reserved for storing
Smolyak levels, which can be adjusted according to the maximum permitted
deepness of interpolation.

\input{include/assets/algorithms/construct}
The pseudocode of the construction stage is given in \aref{construct} called
\token{Construct}. The input \token{target} is a function $\f$ to be
approximated. The output \token{surrogate} is a set of tuples $\{ (\vl_k,
\surplus(\vx_{\vl_k}) \}_k$, which is a comprehensive characterization of an
interpolant. The key steps of \token{Construct} are as follows.

\begin{compactlist}

\point{Line~4:} Each iteration of the outermost loop corresponds to a level of
Smolyak's interpolation, which is denoted by $l$ in \eref{smolyak-hierarchical}
and by \token{level} in the code. The \token{indices} variable is a working set
containing the indices of the current (in progress) level. The set is initially
populated on line~2 by the indices of level~0, which is just $\{ (\v{0}, \v{0})
\}$ for the Newton--Cotes grid.

\point{Line~5:} \token{grid.ComputeNodes} takes a set of indices and returns the
corresponding (multidimensional) nodes of the underlying sparse grid; see
\sref{collocation-nodes}.

\point{Line~6:} \token{Invoke} exercises the target function at each of the
given nodes and returns the corresponding values. This is a prominent candidate
for parallelization since each collocation node can be evaluated independently
from the rest.

\point{Line~7:} \token{Evaluate} utilizes the interpolant constructed so far in
order to calculate approximations to the true values of the target function
obtained on line~6. The \token{Evaluate} function is \aref{evaluate}, and it
will be discussed separately.

\point{Line~9--10:} \token{Append} ameliorates the surrogate by extending it
with the indices and surpluses of the current iteration.

\point{Line~11:} The check is to stop the algorithm when it reaches a
user-defined limit such as the maximum level of interpolation, number of
\token{target}'s invocations, or time spent on interpolation.

\point{Line~14:} The loop iterates over the surpluses of the current level and
identifies those indices that need refinement. The \token{IsAccurate} function
represents a refinement strategy and might not necessarily be solely based on
the surpluses. In our experiments, we use the formula given in \eref{score}.

\point{Line~18:} The check is to stop the algorithm when there is nothing left
to refine, which is dictated by \token{IsAccurate}.

\point{Line~21:} \token{grid.ComputeNeighbors} takes the indices selected for
refinement and returns the corresponding child indices of the next level; see
\fref{rule} and \sref{adaptivity}.

\end{compactlist}

\input{include/assets/algorithms/evaluate}
Let us now turn to the usage stage of interpolant. The corresponding pseudocode
is given in \aref{evaluate}, which is called \token{Evaluate}. This algorithm is
also involved in the construction stage; see \aref{construct}, line~7. The main
steps of the \token{Evaluate} algorithm are given below.

\begin{compactlist}

\point{Line~6:} The inner loop directly corresponds to
\eref{smolyak-hierarchical} with the exception that, due to adaptivity, the loop
generally iterates over a subset of the summands in the aforementioned equation,
which we discussed in \sref{adaptivity}.

\point{Line~6:} \token{basis.Compute} takes a pair $(\vi, \vj)$ and a point and
returns the value of the (multidimensional) basis function corresponding to the
pair evaluated at the point; see \sref{basis-functions}.

\end{compactlist}

To recapitulate, in this section, we have presented the key component of the
proposed framework for probabilistic analysis of electronic systems: an
efficient approach to multidimensional interpolation. The interpolation
technique is based on the Smolyak algorithm, which enables the interpolation to
be performed in an adaptive hierarchical manner, highly beneficial for practical
computations. The overall technique has been consolidated in \aref{construct}
and \aref{evaluate}.
